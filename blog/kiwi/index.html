<!doctype html><html lang=en><head><meta charset=utf-8><script async src="https://www.googletagmanager.com/gtag/js?id=G-64J3C3W6RC"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-64J3C3W6RC")</script><title>Kiwi &ndash; Andrea Radaelli</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax.css><link rel=icon href=/favicon.ico type=image/x-icon><link rel=alternate type=application/rss+xml href=/blog/index.xml title="Andrea Radaelli's Blog"></head><body><header><nav><a href=/>Home</a>
<a href=/about/>About</a></nav></header><main><article class=article-container><div class=article-content><h1>Kiwi</h1><p class=page-date>23 July 2023</p><p>Lately I wanted to increase my hands-on knowledge about <a href=https://aws.amazon.com/>Amazon Web Services (AWS)</a>.</p><p>For me, the best way to learn a new technology is trying to build something with it. So, I spent some time pondering and come up with a the idea of creating a simple &ldquo;Twitter like&rdquo; web application.</p><p>The requirements I set were:</p><ul><li>To be able to see all the messages posted in the last 24h.</li><li>To be able to post new messages.</li><li>To automatically simulate multiple users posting messages every minute.</li><li>To be able to scale for thousands of visitors.</li></ul><p>I started by sketching a rough design for the architecture and then I went &ldquo;shopping&rdquo; on the AWS product page to see which services I could use. This is the end result:</p><p><figure><a href=/blog/kiwi/images/architecture.png><picture><source media=(min-width:600px) srcset=/blog/kiwi/images/architecture_hu_3baf0949dbcea648.png><source media=(min-width:1200px) srcset=/blog/kiwi/images/architecture_hu_2e625dcf58c6bd86.png><img class=md__image src=/blog/kiwi/images/architecture_hu_f196c6d9c727772.png alt="Architecture Diagram"></picture></a><figcaption><small><i>Architecture Diagram</i></small></figcaption></figure></p><p>Key decisions:</p><ul><li>The frontend will be a static <a href=https://en.wikipedia.org/wiki/Single-page_application>single-page application (SPA)</a> which I could host directly on AWS S3.</li><li>The backend endpoint for the APIs will be hosted on AWS Api Gateway.</li><li>The backend services will be fully <a href=https://en.wikipedia.org/wiki/Serverless_computing>serverless</a> using AWS Lambda.</li><li>The storage for the system will be managed through DynamoDB.</li><li>Queues will use AWS Simple Query Service (SQS).</li><li>The whole infrastructure will be committed in the repository as <a href=https://en.wikipedia.org/wiki/Infrastructure_as_code>code</a> by leveraging AWS Cloud Development Kit (CDK)</li></ul><p>For the frontend, I chose Angular for no other reason than to keep it fresh in my mind. After all, this project is solely for learning purposes.</p><p>I made sure that I could host the whole system within the limits of the <a href=https://aws.amazon.com/free/>AWS Free Tier</a>, so that I would not have to pay in order to host a simple demo web application.</p><p>Here are a couple of tricks that I have learned.</p><h2 id=sqs-long-polling>SQS Long Polling</h2><p>Services monitoring SQS queues do so by periodically polling the queues to check for new messages. As SQS is priced on the number of request, it&rsquo;s essential to minimize the number of polls.</p><p>The recommended approach to achieve this is by enabling <a href=https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html>&ldquo;Long polling&rdquo;</a>. Long polling allows Amazon SQS to wait until a message is available in a queue before sending a response, significantly reducing the number of requests per second.</p><p>After setting the maximum wait time allowed for long polling, which is 20 seconds, I was expecting to see 3 requests per second in my queues. However, to my surprise, I noticed 15 requests per second in the monitoring dashboard. The mystery was solved by this <a href=https://stackoverflow.com/questions/53372107/aws-sqs-long-polling-doesnt-reduce-empty-receives>Stackoverflow question</a>. It explains that queues wired to Lambdas (as in my architecture) are polled by 5 instances of the same Lambda by default, and this cannot be changed. While this caused a higher request rate, it is not a major concern for me since I have only two queues, and I will still be well below the threshold of the Free Tier for SQS.</p><h2 id=backend-endpoints-in-the-frontend>Backend endpoints in the Frontend</h2><p>Integrating the URL of my backend endpoint into the frontend using AWS CDK proved to be a bit challenging.</p><p>Given that the frontend is static, it becomes necessary to hardcode the backend URL before building the Angular project. However, the nature of AWS CDK is to generate semi-random names for the declared services, making it impossible to guarantee that they won&rsquo;t change with future edits. Ideally, the AWS CDK should trigger the frontend build as soon as it knows the backend URL, but unfortunately, that&rsquo;s not possible.</p><p>The workaround I discovered is to split the architecture into two separate <a href=https://docs.aws.amazon.com/cdk/v2/guide/stacks.html>&ldquo;stacks&rdquo;</a>: one for the backend and one for the frontend. The backend stack can then utilize the <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.CfnOutput.html>&ldquo;output construct&rdquo;</a> to write the backend URL to a JSON file that can be directly referenced by the frontend.</p><h2 id=live-demo>Live Demo</h2><p><figure><a href=/blog/kiwi/images/screenshot.png><picture><source media=(min-width:600px) srcset=/blog/kiwi/images/screenshot_hu_f79c646172c3c39.png><source media=(min-width:1200px) srcset=/blog/kiwi/images/screenshot_hu_ae487837b5d89d66.png><img class=md__image src=/blog/kiwi/images/screenshot_hu_a11222ad5dd5622e.png alt=Screenshot></picture></a><figcaption><small><i>Screenshot</i></small></figcaption></figure></p><p>The live demo is hosted at: <a href=http://kiwi.aradaelli.com>http://kiwi.aradaelli.com</a></p><p>Source code: <a href=https://github.com/skilion/kiwi>https://github.com/skilion/kiwi</a></p></div></article></main><footer></footer></body></html>